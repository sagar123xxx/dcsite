<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Untitled Document</title>
<link rel="stylesheet" href="http://code.jquery.com/mobile/1.3.2/jquery.mobile-1.3.2.min.css" />
<script src="http://code.jquery.com/jquery-1.9.1.min.js"></script>
<script src="http://code.jquery.com/mobile/1.3.2/jquery.mobile-1.3.2.min.js"></script>

<style  type="text/css">
body{
font-family: "Segoe UI";
}
.ui-icon-menu-bars{
	
	background-image:url(image/menu%20bar.jpg) !important;
	border:none;
	border-radius: 0px;
}
.ui-icon-menu-about{
	
	background-image:url(image/about-icon.png) !important;
	border:none;
	border-radius: 0px;
}
.content-1{

background-color:rgba(255,255,255,0.6);

border:1px solid #BBB;
padding:0px;
	


margin: 0 auto;
}

h1{
	color:#555;
	font-size:1.2em;
	padding-left:1px;	
	font-weight:normal;
	margin:2 auto;
	
}
h2{
	color:#444;
	font-size:1em;
	padding-left:2px;
	font-weight:normal;
	font-style:italic;
	
}
h3{
	color  : #444;
	font-size:0.9em;
	font-weight:normal;
	font-style:italic;
	padding-left:2px;
	
}
p{
	font-size:0.8em;
	padding:5px;
	padding-bottom:0px;
	text-indent:10px;
	text-align:justify;
}
ul {
	padding-top:0px;
	font-size:0.8em;
	
}
li{
	padding-bottom:1px;	
}
img{
	width:99%;
	margin:0 auto;
	padding:1px;
	
	
}
.section{
	width:100%;
	background-color:#FFF;
	border:1px solid #BBB;
	margin:0 auto;	
}
</style>
<script src="event.js"> </script>
</head> 

<body>

<div data-role="page"  id="page">
  <div data-role="header" data-theme="c">
	<a href="#left-panel" data-role="button" data-inline="true" data-icon="menu-bars" data-iconpos="notext"  data-corners="false" class="no-border"></a>
        <h1>Home</h1> 
    	<a href="#right-panel" data-position="right" data-role="button" data-inline="true" data-icon="menu-about" data-iconpos="notext"  data-corners="false" class="no-border"></a>
    </div>
    
	<div data-role="content" class="content"> 
    <div class="content-1">
    	<h2> Subject :</h2>
        <h1> Distributed Computing</h1>
        
        <h2>  Class : </h2>
        <h1> MCA 3rd Year </h1>
    </div>
    
     </div>
  <div data-role="footer" data-position="fixed" data-theme="c" id="footer">  <h1>&copy; MCA 3rd Year</h1> </div>
  
  <div data-role="panel" id="left-panel" data-theme="c" data-inset="false"  data-display="overlay" >

                         <ul data-role="listview" data-inset="false" data-filter-placeholder="Search chp" data-filter="true">
                <li><a href="chapter1.html" data-transition="flip" data-rel="page" >Unit1</a></li>
                <li><a href="#" data-transition="flip" data-rel="page">Unit 2</a></li>
                <li><a href="#" data-transition="flip" data-rel="page">Unit 3</a></li>
                <li><a href="#" data-transition="flip" data-rel="page">Unit 4</a></li>
                <li><a href="#" data-transition="flip" data-rel="page">Unit 5</a></li>
                <li><a href="#" data-transition="flip" data-rel="page">Unit 6</a></li>
                                <li><a href="#unit7" data-transition="flip" data-rel="page">Unit 7</a></li>
                <li><a href="#page" data-transition="flip" data-rel="page">Home</a></li>
            </ul>

  </div>
   <div data-role="panel" id="right-panel" data-theme="c" data-inset="false"  data-display="reveal" data-position="right">

            


  </div>

</div>
<div data-role="page" id ="unit7">  
	<div data-role="header" data-theme="c" > 
<a href="#left-panel1" data-role="button" data-inline="true" data-icon="menu-bars" data-iconpos="notext"  data-corners="false" class="no-border"></a>
    
<h1> Unit 7</h1>
<a href="#right-panel1"   data-role="button" data-inline="true" data-icon="menu-about" data-iconpos="notext"  data-corners="false" class="no-border"></a>
</div>

<div data-role="panel" id="left-panel1" data-theme="c" data-inset="false"  data-display="overlay" >

             <ul data-role="listview" data-inset="false" data-filter-placeholder="Search chp" data-filter="true">
                <li><a href="#" data-transition="flip" data-rel="page" >Unit1</a></li>
                <li><a href="#" data-transition="flip" data-rel="page">Unit 2</a></li>
                <li><a href="#" data-transition="flip" data-rel="page">Unit 3</a></li>
                <li><a href="#" data-transition="flip" data-rel="page">Unit 4</a></li>
                <li><a href="#" data-transition="flip" data-rel="page">Unit 5</a></li>
                <li><a href="#" data-transition="flip" data-rel="page">Unit 6</a></li>
                <li><a href="#unit7" data-transition="flip" data-rel="page">Unit 7</a></li>
                <li><a href="index.html" data-transition="flip" data-rel="page">Home</a></li>
            </ul>


  </div>
  <div data-role="panel" id="right-panel1" data-theme="c" data-inset="false"  data-display="reveal" data-position="right">

          

  </div>

<div data-role="content" data-theme="c" >  
	<div class="section"> 
    	<h1>Consistency and Replication</h1>
        <hr />
    	<h2> Introduction </h2> 
		<p> 
        	Data are generally replicated to enhance reliability or improve performance.
            One of the major problems is keeping replicas consistent.
            Informally, this means that when one copy is updated we need to ensure that the other copies are updated as well;
             otherwise the replicas will no longer be the same.
        
        </p>
    	<h2> Reasons for Replication </h2>
        <p>
        	There are two primary reasons for replicating data: reliability and performance.
First, data are replicated to increase the reliability of a system. 

        </p>
                <p>
                If a file system has been replicated it may be possible to continue working after one replica crashes by simply switching to one of the other replicas. Also, by maintaining multiple copies, it becomes possible to provide better protection against corrupted data.</p>
	                
    	        <p>
                	For example, imagine there are three copies of a file and every read and write operation is performed on each copy. We can safeguard ourselves against a single, failing write operation, by considering the value that is returned by at least two copies as being the correct one.
                </p>            
				        <p>
                        
                        	The other reason for replicating data is performance. Replication for performance is important when the distributed system needs to scale in numbers and geographical area.
                        </p>                
                        
                        <p>
                        
                        	For example,when an increasing number of processes needs to access data that are managed by a single server .In that case, performance can be improved by replicating the server and subsequently dividing the work.
                        </p>
        <h2>Replication as Scaling Technique</h2>
        <p>
        		Replication and caching for performance are widely applied as scaling techniques. Scalability issues generally appear in the form of performance problems. Placing copies of data close to the processes using them can improve performance through reduction of access time and thus solve scalability problems.
        </p>
        <h2>
        	Data-centric Consistency Models:
        </h2>
        <p>
        	A data store may be physically distributed across multiple machines. In particular, each process that can access data from the store is assumed to have a local (or nearby) copy available of the entire store. Write operations are propagated to the other copies.
        </p>
        <img  src="image/fig7.1.png"/>
        <h2>
        	Continuous Consistency
        </h2>
        <p>
        	There are different ways for applications to specify what inconsistencies they can tolerate.
        </p>
        <p>
        	<ul>
            	<li>deviation in numerical values between replicas</li>
                <li>deviation in staleness between replicas</li>
                <li>deviation with respect to the ordering of update operations</li>
            </ul>
        </p>
       
        <p>
        Measuring inconsistency in terms of numerical deviations can be used by applicationsfor which the data have numerical semantics. One obvious example isthe replication of records containing stock market prices.
        	</p>
            <p>Staleness deviations relate to the last time a replica was updated. For some applications, it can be tolerated that a replica provides old data as long as it is not too old.</p>
            <p>
            	There are classes of applications in which the ordering of updates are allowed to be different at the various replicas that come under deviation with respect to the ordering of update operation.
            </p>
            <p>
            	A consistency unit, abbreviated to conit. A conit specifies the unit over which consistency is to be measured. For example, in our stock-exchange example, a conit could be defined as a record representing a single stock. Another example is an individual weather report.
            </p>
            <p>
            To illustrate numerical and ordering deviations, consider the two replicas as shown,
            </p>
            <img src="image/fig7.2.png"/>
        <h2></h2>
        <p>We see two replicas that operate on a conit containing the dataitems x and y. Both variables are assumed to have been initialized to O.Replica Areceived the operation<h2>5,B : x ~x +2</h2></p>

        <p>From replica B and has made it permanent (i.e., the operation has beencommittedat A and cannot be rolled back). Replica A has three tentative update operations:8,A, 12,A, and 14,A, which brings its ordering deviation to 3. Also note thatdue to the last operation 14,A, A's vector clock becomes (15,5).
The only operation from B that A has not yet seen is IO,B, bringing itsnumerical deviation with respect to operations to 1. In this example, the weight ofthis deviation can be expressed as the maximum difference between the (committed)values of x and y at A, and the result from operations at B not seen by A. Thecommitted value at A is (x,y) = (2,0), whereas the-for A unseen-operation at Byields a difference of y = 5.
</p>
<p>
A similar reasoning shows that B has two tentative update operations: 5,Band 10,B , which means it has an ordering deviation of 2. Because B has not yetseen a single operation from A, its vector clock becomes (0, 11). The numericaldeviation is 3 with a total weight of 6. This last value comes from the fact B'scommitted value is (x,y) = (0,0), whereas the tentative operations at A willalready bring x to 6.</p>
<p>
If a conit represents a lot of data, such as a complete database,then updates are aggregated for all the data in the conit. As a consequence, thismay bring replicas sooner in an inconsistent state.

</p>
<h2>Consistent Ordering of Operations </h2>
<p> Besides continuous consistency, there is a huge body of work on data-centricconsistency models.</p>
<h3>Sequential Consistency: </h3> 
<p> A data store is sequentially consistent when the result of any execution is the same as if the (read and write) operations by all processes on the data store. </p>
<p> 	We used a special notation in which we draw the operations of a process along a time axis. The time axis is always drawn horizontally, with time increasing from left to right. The symbols mean that a write by process P; to data item x with the value aand a read from that item by Pi returning b have been done, respectively. We assume that each data item is initially NIL. When there is no confusion concerning which process is accessing data, we omit the index from the symbols Wand R.</p>

<img src="image/fig7.3.png"/>
<p>

	PI does a write to a data item x, modifying its value to a. Note that, in principle, this operation WI (x)a is first performed on a copy of the data store that is local to PI, and is then subsequently propagated to the other local copies. In our example, P2 later reads the value NIL, and sometime after that a (from its local copy of the store). What we are seeing here is that it took some time to propagate the update of x to P2, which is perfectly acceptable.
 </p>
 <img src="image/fig7.4.png"/>
 	<h3>a) A sequentially consistent data store.  </h3>
 <img src="image/fig7.5.png"/>
  	<h3> (b) A data store that is not sequentially consistent.</h3>
 <p>
 	In Fig (a) process PI first performs W(x)ato x. Later (in absolute time), process P2 also performs a write operation, by setting the value of x to b. However, both processes P3 and P4 first read value b, and later value a. In other words, the write operation of process P2 appears to have taken place before that of PI•
 </p>
 <p>
 In contrast, Fig (b) violates sequential consistency because not all processes see the same interleaving of write operations. In particular, to process P3, it appears as if the data item has first been changed to b, and later to a. On the other hand, P4 will conclude that the final value is b


  </p>
  <h3>Causal Consistency: </h3>
  <p>
  	For a data store to be considered causally consistent, it is necessary that the store obeys the following condition:
  </p>
  <p>
  Writes that are potentially causally related must be seen by all processes in the same order. Concurrent writes may be seen in a different order on different machines.
   </p>
        <img src="image/fig7.6.png"/>
        <p>
        Here we have an event sequence that is allowed with a causally-consistent store, but which is forbidden with a sequentially-consistent store or a strictly consistent store. The thing to note is that the writes Wz(x)band WI (x)c are concurrent, so it is not required that all processes see them in the same order.
        </p>
        <p> This sequence is allowed with a causally-consistent store, but not with a sequentially consistent store.</p>
        
        <p>Now consider a second example. In Fig.(a) we have Wz(x)b potentiallydepending on WI (x)a because the b may be a result of a computation involvingthe value read by Rz(x)a. The two writes are causally related, so all processesmust see them in the same order. Therefore, Fig.(a) is incorrect. On the other hand, in Fig.(b) the read has been removed, so WI (x)a and Wz(x)b are nowconcurrent writes. A causally-consistent store does not require concurrent writesto be globally ordered, so Fig.(b) is correct. Note that Fig.(b) reflects asituation that would not be acceptable for a sequentially consistent store. </p>
        <img src="image/fig7.7.png"/>
        <h3> (a)	A violation of a causally-consistent store. </h3>
        <img src="image/fig7.8.png"/>
		<h3>(b) A correct sequence of eventsin a causally-consistent store.</h3>        
        <p> Implementing causal consistency requires keeping track of which processes have seen which writes.</p>
        <h3>Grouping Operations:</h3>
        <p> Necessary criteria for correct synchronization:</p>
        <p> <ul> 
        		<li>An acquire access of a synchronization variable, not allowed to perform until all updates to guarded shared data have been performed with respect to that process.</li>
                <li>Before exclusive mode access to synchronization variable by process is allowed to perform with respect to that process, no other process may hold synchronization variable, not even in nonexclusive mode.

 </li>
                <li>After exclusive mode access to synchronization variable has been performed, any other process' next nonexclusive mode access to that synchronization variable may not be performed until it has performed with respect to that variable's owner.</li>
        </ul></p>
        <p> The first condition says that when a process does an acquire, the acquire may notcomplete (i.e., return control to the next statement) until all the guarded shareddata have been brought up to date. In other words, at an acquire, all remotechanges to the guarded data must be made visible.

</p>
<p>
The second condition says that before updating a shared data item, a processmust enter a critical section in exclusive mode to make sure that no other processis trying to update the shared data at the same time.
 </p>
        <p> The third condition says that if a process wants to enter a critical region innonexclusive mode, it must first check with the owner of the synchronization variableguarding the critical region to fetch the most recent copies of the guardedshared data.</p>
        
        <p> Fig. shows an example of what is known as entry consistency. Insteadof operating on the entire shared data, in this example we associate locks witheach data item. In this case, P I does an acquire for x, changes x once, after whichit also does an acquire for y. Process P2 does an acquire for x but not for Y'. So thatit will read value a for x, but may read NIL for y. Because process P3 first does anacquire for y, it will read the value b when y is released by Pl'</p>
<img src="image/fig7.9.png"/>        
<h3>Consistency versus Coherence:</h3>
<p> A consistencymodel describes what can be expected with respect to that set when multipleprocesses concurrently operate on that data.Coherencemodels describe what can be expected to only a single data item</p>

	</div>
    

</div>

<div data-role="footer" data-position="fixed" data-theme="c">  <h1> footer</h1>  </div>
</div>
<!-- <div data-role="page" id="page">

<div data-role="header" data-theme="c" > 
<a href="#left-panel1" data-role="button" data-inline="true" data-icon="menu-bars" data-iconpos="notext"  data-corners="false" class="no-border"></a>
    
<h1> Unit 7</h1>
<a href="#right-panel1"   data-role="button" data-inline="true" data-icon="menu-about" data-iconpos="notext"  data-corners="false" class="no-border"></a>
</div>

<div data-role="panel" id="left-panel1" data-theme="c" data-inset="false"  data-display="overlay" >

             <ul data-role="listview" data-inset="false" data-filter-placeholder="Search chp" data-filter="true">
                <li><a href="chapter1.html" data-transition="flip" data-rel="page" >Unit1</a></li>
                <li><a href="#" data-transition="flip" data-rel="page">Unit 2</a></li>
                <li><a href="#" data-transition="flip" data-rel="page">Unit 3</a></li>
                <li><a href="#" data-transition="flip" data-rel="page">Unit 4</a></li>
                <li><a href="#" data-transition="flip" data-rel="page">Unit 5</a></li>
                <li><a href="#" data-transition="flip" data-rel="page">Unit 6</a></li>
                <li><a href="google.com" data-transition="flip" data-rel="page">Unit 7</a></li>
                <li><a href="index.html" data-transition="flip" data-rel="page">Home</a></li>
            </ul>


  </div>
  <div data-role="panel" id="right-panel1" data-theme="c" data-inset="false"  data-display="reveal" data-position="right">

          

  </div>

<div data-role="content" data-theme="c" >  
	<div class="section"> 
    	<h1>Consistency and Replication</h1>
        <hr />
    	<h2> Introduction </h2> 
		<p> 
        	Data are generally replicated to enhance reliability or improve performance.
            One of the major problems is keeping replicas consistent.
            Informally, this means that when one copy is updated we need to ensure that the other copies are updated as well;
             otherwise the replicas will no longer be the same.
        
        </p>
    	<h2> Reasons for Replication </h2>
        <p>
        	There are two primary reasons for replicating data: reliability and performance.
First, data are replicated to increase the reliability of a system. 

        </p>
                <p>
                If a file system has been replicated it may be possible to continue working after one replica crashes by simply switching to one of the other replicas. Also, by maintaining multiple copies, it becomes possible to provide better protection against corrupted data.</p>
	                
    	        <p>
                	For example, imagine there are three copies of a file and every read and write operation is performed on each copy. We can safeguard ourselves against a single, failing write operation, by considering the value that is returned by at least two copies as being the correct one.
                </p>            
				        <p>
                        
                        	The other reason for replicating data is performance. Replication for performance is important when the distributed system needs to scale in numbers and geographical area.
                        </p>                
                        
                        <p>
                        
                        	For example,when an increasing number of processes needs to access data that are managed by a single server .In that case, performance can be improved by replicating the server and subsequently dividing the work.
                        </p>
        <h2>Replication as Scaling Technique</h2>
        <p>
        		Replication and caching for performance are widely applied as scaling techniques. Scalability issues generally appear in the form of performance problems. Placing copies of data close to the processes using them can improve performance through reduction of access time and thus solve scalability problems.
        </p>
        <h2>
        	Data-centric Consistency Models:
        </h2>
        <p>
        	A data store may be physically distributed across multiple machines. In particular, each process that can access data from the store is assumed to have a local (or nearby) copy available of the entire store. Write operations are propagated to the other copies.
        </p>
        <img  src="image/fig7.1.png"/>
        <h2>
        	Continuous Consistency
        </h2>
        <p>
        	There are different ways for applications to specify what inconsistencies they can tolerate.
        </p>
        <p>
        	<ul>
            	<li>deviation in numerical values between replicas</li>
                <li>deviation in staleness between replicas</li>
                <li>deviation with respect to the ordering of update operations</li>
            </ul>
        </p>
       
        <p>
        Measuring inconsistency in terms of numerical deviations can be used by applicationsfor which the data have numerical semantics. One obvious example isthe replication of records containing stock market prices.
        	</p>
            <p>Staleness deviations relate to the last time a replica was updated. For some applications, it can be tolerated that a replica provides old data as long as it is not too old.</p>
            <p>
            	There are classes of applications in which the ordering of updates are allowed to be different at the various replicas that come under deviation with respect to the ordering of update operation.
            </p>
            <p>
            	A consistency unit, abbreviated to conit. A conit specifies the unit over which consistency is to be measured. For example, in our stock-exchange example, a conit could be defined as a record representing a single stock. Another example is an individual weather report.
            </p>
            <p>
            To illustrate numerical and ordering deviations, consider the two replicas as shown,
            </p>
            <img src="image/fig7.2.png"/>
        <h2></h2>
        <p>We see two replicas that operate on a conit containing the dataitems x and y. Both variables are assumed to have been initialized to O.Replica Areceived the operation<h2>5,B : x ~x +2</h2></p>

        <p>From replica B and has made it permanent (i.e., the operation has beencommittedat A and cannot be rolled back). Replica A has three tentative update operations:8,A, 12,A, and 14,A, which brings its ordering deviation to 3. Also note thatdue to the last operation 14,A, A's vector clock becomes (15,5).
The only operation from B that A has not yet seen is IO,B, bringing itsnumerical deviation with respect to operations to 1. In this example, the weight ofthis deviation can be expressed as the maximum difference between the (committed)values of x and y at A, and the result from operations at B not seen by A. Thecommitted value at A is (x,y) = (2,0), whereas the-for A unseen-operation at Byields a difference of y = 5.
</p>
<p>
A similar reasoning shows that B has two tentative update operations: 5,Band 10,B , which means it has an ordering deviation of 2. Because B has not yetseen a single operation from A, its vector clock becomes (0, 11). The numericaldeviation is 3 with a total weight of 6. This last value comes from the fact B'scommitted value is (x,y) = (0,0), whereas the tentative operations at A willalready bring x to 6.</p>
<p>
If a conit represents a lot of data, such as a complete database,then updates are aggregated for all the data in the conit. As a consequence, thismay bring replicas sooner in an inconsistent state.

</p>
<h2>Consistent Ordering of Operations </h2>
<p> Besides continuous consistency, there is a huge body of work on data-centricconsistency models.</p>
<h3>Sequential Consistency: </h3> 
<p> A data store is sequentially consistent when the result of any execution is the same as if the (read and write) operations by all processes on the data store. </p>
<p> 	We used a special notation in which we draw the operations of a process along a time axis. The time axis is always drawn horizontally, with time increasing from left to right. The symbols mean that a write by process P; to data item x with the value aand a read from that item by Pi returning b have been done, respectively. We assume that each data item is initially NIL. When there is no confusion concerning which process is accessing data, we omit the index from the symbols Wand R.</p>

<img src="image/fig7.3.png"/>
<p>

	PI does a write to a data item x, modifying its value to a. Note that, in principle, this operation WI (x)a is first performed on a copy of the data store that is local to PI, and is then subsequently propagated to the other local copies. In our example, P2 later reads the value NIL, and sometime after that a (from its local copy of the store). What we are seeing here is that it took some time to propagate the update of x to P2, which is perfectly acceptable.
 </p>
 <img src="image/fig7.4.png"/>
 	<h3>a) A sequentially consistent data store.  </h3>
 <img src="image/fig7.5.png"/>
  	<h3> (b) A data store that is not sequentially consistent.</h3>
 <p>
 	In Fig (a) process PI first performs W(x)ato x. Later (in absolute time), process P2 also performs a write operation, by setting the value of x to b. However, both processes P3 and P4 first read value b, and later value a. In other words, the write operation of process P2 appears to have taken place before that of PI•
 </p>
 <p>
 In contrast, Fig (b) violates sequential consistency because not all processes see the same interleaving of write operations. In particular, to process P3, it appears as if the data item has first been changed to b, and later to a. On the other hand, P4 will conclude that the final value is b


  </p>
  <h3>Causal Consistency: </h3>
  <p>
  	For a data store to be considered causally consistent, it is necessary that the store obeys the following condition:
  </p>
  <p>
  Writes that are potentially causally related must be seen by all processes in the same order. Concurrent writes may be seen in a different order on different machines.
   </p>
        <img src="image/fig7.6.png"/>
        <p>
        Here we have an event sequence that is allowed with a causally-consistent store, but which is forbidden with a sequentially-consistent store or a strictly consistent store. The thing to note is that the writes Wz(x)band WI (x)c are concurrent, so it is not required that all processes see them in the same order.
        </p>
        <p> This sequence is allowed with a causally-consistent store, but not with a sequentially consistent store.</p>
        
        <p>Now consider a second example. In Fig.(a) we have Wz(x)b potentiallydepending on WI (x)a because the b may be a result of a computation involvingthe value read by Rz(x)a. The two writes are causally related, so all processesmust see them in the same order. Therefore, Fig.(a) is incorrect. On the other hand, in Fig.(b) the read has been removed, so WI (x)a and Wz(x)b are nowconcurrent writes. A causally-consistent store does not require concurrent writesto be globally ordered, so Fig.(b) is correct. Note that Fig.(b) reflects asituation that would not be acceptable for a sequentially consistent store. </p>
        <img src="image/fig7.7.png"/>
        <h3> (a)	A violation of a causally-consistent store. </h3>
        <img src="image/fig7.8.png"/>
		<h3>(b) A correct sequence of eventsin a causally-consistent store.</h3>        
        <p> Implementing causal consistency requires keeping track of which processes have seen which writes.</p>
        <h3>Grouping Operations:</h3>
        <p> Necessary criteria for correct synchronization:</p>
        <p> <ul> 
        		<li>An acquire access of a synchronization variable, not allowed to perform until all updates to guarded shared data have been performed with respect to that process.</li>
                <li>Before exclusive mode access to synchronization variable by process is allowed to perform with respect to that process, no other process may hold synchronization variable, not even in nonexclusive mode.

 </li>
                <li>After exclusive mode access to synchronization variable has been performed, any other process' next nonexclusive mode access to that synchronization variable may not be performed until it has performed with respect to that variable's owner.</li>
        </ul></p>
        <p> The first condition says that when a process does an acquire, the acquire may notcomplete (i.e., return control to the next statement) until all the guarded shareddata have been brought up to date. In other words, at an acquire, all remotechanges to the guarded data must be made visible.

</p>
<p>
The second condition says that before updating a shared data item, a processmust enter a critical section in exclusive mode to make sure that no other processis trying to update the shared data at the same time.
 </p>
        <p> The third condition says that if a process wants to enter a critical region innonexclusive mode, it must first check with the owner of the synchronization variableguarding the critical region to fetch the most recent copies of the guardedshared data.</p>
        
        <p> Fig. shows an example of what is known as entry consistency. Insteadof operating on the entire shared data, in this example we associate locks witheach data item. In this case, P I does an acquire for x, changes x once, after whichit also does an acquire for y. Process P2 does an acquire for x but not for Y'. So thatit will read value a for x, but may read NIL for y. Because process P3 first does anacquire for y, it will read the value b when y is released by Pl'</p>
<img src="image/fig7.9.png"/>        
<h3>Consistency versus Coherence:</h3>
<p> A consistencymodel describes what can be expected with respect to that set when multipleprocesses concurrently operate on that data.Coherencemodels describe what can be expected to only a single data item</p>

	</div>
    

</div>

<div data-role="footer" data-position="fixed" data-theme="c">  <h1> footer</h1>  </div>


</div>


-->
</body>
</html>
